{#
  Required variables:
  - prices (array)
  - company (object with id, tickerSymbol)
  - interval (string)
  - timeRange (string)
  - enableRealTimeUpdates (boolean)
#}
<script>
document.addEventListener('DOMContentLoaded', function() {
    let priceData = {{ prices|json_encode|raw }};
    const companyId = {{ company.id }};
    const companySymbol = "{{ company.tickerSymbol|e('js') }}"; // Ensure ticker is JS escaped
    let currentInterval = "{{ interval|e('js') }}";
    let currentTimeRange = "{{ timeRange|e('js') }}";
    const enableRealTimeUpdates = {{ enableRealTimeUpdates ? 'true' : 'false' }};

    let stockChart = null; // Initialize chart variable



    // Function to prepare data for Chart.js
    function prepareChartData(data) {
        if (!Array.isArray(data) || data.length === 0) {
            return { labels: [], prices: [], volumes: [], ohlcData: [] };
        }

        data.sort((a, b) => new Date(a.date) - new Date(b.date));

        const labels = data.map(item => item.date);
        const prices = data.map(item => parseFloat(item.close) || 0);
        const volumes = data.map(item => parseInt(item.volume) || 0);
        const ohlcData = data.map(item => ({
            x: new Date(item.date).getTime(), // For time scale if ever used
            date: item.date, // For category scale and easier reference
            o: parseFloat(item.open) || 0,
            h: parseFloat(item.high) || 0,
            l: parseFloat(item.low) || 0,
            c: parseFloat(item.close) || 0,
            v: parseInt(item.volume) || 0
        }));

        return { labels, prices, volumes, ohlcData };
    }

    let { labels, prices, volumes, ohlcData } = prepareChartData(priceData);

    // Handle no data case initially
    if (!Array.isArray(priceData) || priceData.length === 0) {
        console.warn("No price data available to display chart.");
        const chartContainer = document.querySelector('.stock-chart-container');
        const noDataMsg = document.querySelector('.no-data-message');
        const mainChartCanvas = document.getElementById('stockPriceChart');

        if (noDataMsg) {
            noDataMsg.style.display = 'block';
        }

        if (mainChartCanvas) {
            mainChartCanvas.style.display = 'none';
        }
    }

    // Calculate initial colors based on the first and last close prices
    let startPrice = prices[0];
    let endPrice = prices[prices.length - 1];
    let percentChange = ((endPrice - startPrice) / startPrice) * 100;
    if (isNaN(percentChange) || !isFinite(percentChange)) percentChange = 0;

    let lineColor = percentChange >= 0 ? '#28a745' : '#dc3545';
    let fillColor = percentChange >= 0 ? 'rgba(40, 167, 69, 0.1)' : 'rgba(220, 53, 69, 0.1)';
    let volumeBarColor = percentChange >= 0 ? 'rgba(40, 167, 69, 0.5)' : 'rgba(220, 53, 69, 0.5)';


    const ctx = document.getElementById('stockPriceChart').getContext('2d');

    // Function to create or update the chart
    function createOrUpdateChart(type = 'line') {
        if (stockChart) {
            stockChart.destroy(); // Destroy existing chart instance
        }

        updateChartColorsAndData(); // Ensure colors are up-to-date

        const commonOptions = {
            responsive: true,
            maintainAspectRatio: false,
            interaction: { mode: 'index', intersect: false, axis: 'x' },
            plugins: {
                legend: { display: false },
                tooltip: {
                    backgroundColor: 'rgba(255, 255, 255, 0.9)', titleColor: '#000', bodyColor: '#000',
                    borderColor: '#ddd', borderWidth: 1, padding: 10, displayColors: false,
                    callbacks: {
                        title: (tooltipItems) => {
                            if (!tooltipItems || tooltipItems.length === 0 || !ohlcData[tooltipItems[0].dataIndex]) return '';
                             const dataIndex = tooltipItems[0].dataIndex;
                             return new Date(ohlcData[dataIndex].date).toLocaleDateString('en-US', { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' });
                        },
                        label: (context) => {
                            const dataPoint = ohlcData[context.dataIndex]; // Use ohlcData for OHLCV details
                            if (!dataPoint) return '';

                            if (context.dataset.yAxisID === 'y') { // Price dataset
                                return [
                                    `Open: ${dataPoint.o.toFixed(2)}`, `High: ${dataPoint.h.toFixed(2)}`,
                                    `Low: ${dataPoint.l.toFixed(2)}`, `Close: ${dataPoint.c.toFixed(2)}`
                                ];
                            } else if (context.dataset.yAxisID === 'y1') { // Volume dataset
                                return `Volume: ${dataPoint.v.toLocaleString()}`;
                            }
                            return '';
                        }
                    }}
                }
            },
            scales: {
                x: {
                    type: 'category', // Explicitly set for date strings as labels
                    grid: { display: false },
                    labels: labels, // Important for category scale
                    ticks: {
                        maxTicksLimit: 10,
                        autoSkip: true,
                        callback: function(value, index) { // value is index for category scale
                            if (labels.length === 0) return '';
                            if (labels.length <= 10 || index % Math.ceil(labels.length / 10) === 0) {
                                return new Date(labels[index]).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                            }
                            return '';
                        }
                    }
                },
                y: { // Primary Y-axis for Price
                    position: 'right',
                    grid: { color: 'rgba(0, 0, 0, 0.05)' },
                    ticks: { callback: (value) => '$' + value.toFixed(2) }
                },
                y1: { // Secondary Y-axis for Volume
                    position: 'left', // Position on the left
                    grid: { display: false }, // No grid lines for volume axis
                    ticks: {
                        maxTicksLimit: 4, // Fewer ticks for volume
                        callback: function(value) {
                            if (value >= 1000000000) return (value / 1000000000).toFixed(1) + 'B';
                            if (value >= 1000000) return (value / 1000000).toFixed(1) + 'M';
                            if (value >= 1000) return (value / 1000).toFixed(1) + 'K';
                            return value;
                        }
                    },
                    display: document.getElementById('showVolumeSwitch').checked, // Initially controlled by toggle state
                    // Align the zero line of the volume axis with the bottom of the chart area
                    // This requires a bit more complex scale configuration or a plugin,
                    // but setting 'beginAtZero: true' and positioning left is a good start.
                    beginAtZero: true,
                }
            }
        };

        let datasets = [
            { // Price Dataset (Line, Candlestick, or OHLC)
                label: companySymbol,
                data: (type === 'line') ? prices : ohlcData.map(d => d.c), // Use close prices for invisible line in custom types
                borderColor: lineColor,
                backgroundColor: fillColor,
                borderWidth: 2,
                fill: true,
                tension: 0.1,
                pointRadius: 0,
                pointHoverRadius: 5,
                pointHoverBackgroundColor: lineColor,
                pointHoverBorderColor: '#fff',
                pointHoverBorderWidth: 2,
                yAxisID: 'y', // Associate with primary Y-axis
                type: (type === 'line') ? 'line' : 'line', // Base type is line for custom drawing
            },
            { // Volume Dataset (Bar)
                label: 'Volume',
                data: volumes,
                backgroundColor: volumeBarColor,
                borderColor: 'transparent',
                barThickness: 'flex',
                maxBarThickness: 15,
                categoryPercentage: 0.8,
                barPercentage: 0.9,
                yAxisID: 'y1', // Associate with secondary Y-axis
                type: 'bar', // Explicitly a bar chart
            }
        ];

        // Custom plugin for Candlestick/OHLC drawing
        const financialChartPlugin = {
            id: 'financialChartPlugin',
            afterDatasetsDraw: function(chartInstance) {
                const { ctx, data, chartArea, scales: { x: xScale, y: yScale, y1: volumeYScale } } = chartInstance;
                const currentChartType = document.querySelector('.chart-type-selector .btn.active')?.getAttribute('data-chart-type') || 'line';

                if ((currentChartType !== 'candlestick' && currentChartType !== 'ohlc') || !ohlcData || ohlcData.length === 0 || !chartArea) return;

                ctx.save();
                const barCount = ohlcData.length;
                let barPixelWidth;
                if (barCount > 1) {
                    const x0 = xScale.getPixelForValue(0);
                    const x1 = xScale.getPixelForValue(1);
                    barPixelWidth = (x1 - x0) * 0.7;
                } else if (barCount === 1) {
                    barPixelWidth = (xScale.getPixelForValue(0) - xScale.left) * 0.7;
                    if (isNaN(barPixelWidth) || barPixelWidth <=0) barPixelWidth = Math.max(5, (xScale.right - xScale.left) * 0.1);
                } else {
                    return;
                }
                barPixelWidth = Math.max(1, Math.floor(barPixelWidth));


                ohlcData.forEach((item, index) => {
                    const x = xScale.getPixelForValue(index);
                    // Use the primary Y-axis (yScale) for price drawing
                    const openPx = yScale.getPixelForValue(item.o);
                    const highPx = yScale.getPixelForValue(item.h);
                    const lowPx = yScale.getPixelForValue(item.l);
                    const closePx = yScale.getPixelForValue(item.c);

                    const barColor = item.c >= item.o ? '#28a745' : '#dc3545'; // Green for up, Red for down
                    ctx.strokeStyle = barColor;
                    ctx.lineWidth = 1;

                    // High-low wick (thin line)
                    ctx.beginPath();
                    ctx.moveTo(x, highPx);
                    ctx.lineTo(x, lowPx);
                    ctx.stroke();

                    if (currentChartType === 'candlestick') {
                        ctx.fillStyle = barColor;
                        const bodyTop = Math.min(openPx, closePx);
                        const bodyHeight = Math.abs(openPx - closePx);
                        ctx.fillRect(x - barPixelWidth / 2, bodyTop, barPixelWidth, bodyHeight);
                    } else if (currentChartType === 'ohlc') {
                        const tickPixelWidth = Math.max(2, barPixelWidth * 0.25);
                        // Open tick (left)
                        ctx.beginPath();
                        ctx.moveTo(x - barPixelWidth / 2, openPx);
                        ctx.lineTo(x, openPx);
                        ctx.stroke();
                        // Close tick (right)
                        ctx.beginPath();
                        ctx.moveTo(x, closePx);
                        ctx.lineTo(x + barPixelWidth / 2, closePx);
                        ctx.stroke();
                    }
                });
                ctx.restore();
            }
        };


        stockChart = new Chart(ctx, {
            type: type === 'line' ? 'line' : 'bar', // Base type for Chart.js, plugin draws over
            data: {
                labels: labels,
                datasets: datasets
            },
            options: commonOptions,
            plugins: [financialChartPlugin] // Add the custom plugin
        });

        console.log(`Chart created/updated with type: ${type}`);
    }

    // Initial chart creation - if we have data
    if (priceData && priceData.length > 0) {
        createOrUpdateChart('line'); // Start with line chart
        console.log('Initial chart created with', priceData.length, 'data points');
    } else {
        console.warn('No initial price data available for chart');
    }


    function updateChartColorsAndData() {
        if (prices.length === 0) {
            lineColor = '#868e96'; // Neutral gray
            fillColor = 'rgba(134, 142, 150, 0.1)';
            volumeBarColor = 'rgba(134, 142, 150, 0.5)';
        } else {
            startPrice = prices[0];
            endPrice = prices[prices.length - 1];
            percentChange = ((endPrice - startPrice) / startPrice) * 100;
            if (isNaN(percentChange) || !isFinite(percentChange)) percentChange = 0;

            lineColor = percentChange >= 0 ? '#28a745' : '#dc3545';
            fillColor = percentChange >= 0 ? 'rgba(40, 167, 69, 0.1)' : 'rgba(220, 53, 69, 0.1)';
            volumeBarColor = percentChange >= 0 ? 'rgba(40, 167, 69, 0.5)' : 'rgba(220, 53, 69, 0.5)';
        }

        if (stockChart && stockChart.data.datasets.length > 0) {
            // Update price dataset colors (index 0)
            const priceDataset = stockChart.data.datasets[0];
            if (priceDataset.type === 'line') { // Only update line colors if it's a line chart
                 priceDataset.borderColor = lineColor;
                 priceDataset.backgroundColor = fillColor;
                 priceDataset.pointHoverBackgroundColor = lineColor;
            }
            // Candlestick/OHLC colors are handled by the plugin

            // Update volume dataset colors (index 1)
            const volumeDataset = stockChart.data.datasets[1];
            if (volumeDataset) {
                 volumeDataset.backgroundColor = volumeBarColor;
            }
        }
    }


    function updateChartType(type) {
        console.log(`Changing chart type to: ${type}`);

        // Make sure we have data to display
        if (!ohlcData || ohlcData.length === 0) {
            console.warn("Cannot update chart type - no data available");
            return;
        }

        // Recreate the chart with the new type configuration
        createOrUpdateChart(type);

        // Ensure volume visibility is maintained after recreation
        const volumeSwitch = document.getElementById('showVolumeSwitch');
        if (volumeSwitch && stockChart && stockChart.options && stockChart.options.scales && stockChart.options.scales.y1) {
            stockChart.options.scales.y1.display = volumeSwitch.checked;
            if (stockChart.data.datasets.length > 1) {
                stockChart.data.datasets[1].hidden = !volumeSwitch.checked;
            }
            stockChart.update('none');
        }
    }

    // Chart type switching functionality
    const chartTypeButtons = document.querySelectorAll('[data-chart-type]');
    chartTypeButtons.forEach(button => {
        button.addEventListener('click', function() {
            chartTypeButtons.forEach(btn => btn.classList.remove('active'));
            this.classList.add('active');
            const chartType = this.getAttribute('data-chart-type');
            console.log(`Switching chart type to: ${chartType}`);
            updateChartType(chartType);
        });
    });

    // Volume toggle functionality
    const volumeSwitch = document.getElementById('showVolumeSwitch');

    if (volumeSwitch) {
        volumeSwitch.addEventListener('change', function() {
            console.log(`Volume toggle switched to: ${this.checked ? 'on' : 'off'}`);
            if (stockChart) {
                // First make sure the y1 scale display property is set correctly
                if (stockChart.options.scales.y1) {
                    stockChart.options.scales.y1.display = this.checked;
                }

                // Then also toggle the volume dataset visibility
                if (stockChart.data.datasets.length > 1) {
                    stockChart.data.datasets[1].hidden = !this.checked;
                }

                stockChart.update('none'); // 'none' for no animation
            }
        });

        // Initial state based on checkbox
        if (stockChart) {
            // Set both the scale display and dataset visibility
            if (stockChart.options.scales.y1) {
                stockChart.options.scales.y1.display = volumeSwitch.checked;
            }

            if (stockChart.data.datasets.length > 1) {
                stockChart.data.datasets[1].hidden = !volumeSwitch.checked;
            }

            stockChart.update('none');
        }
    }


    // Crosshair functionality
    const chartContainerEl = document.querySelector('.stock-chart-container'); // The main div
    const crosshairVertical = document.querySelector('.crosshair-vertical');
    const crosshairHorizontal = document.querySelector('.crosshair-horizontal');
    const priceLabel = document.querySelector('.price-label');
    const dateLabel = document.querySelector('.date-label');
    const chartOverlayInfo = document.querySelector('.chart-overlay-info');
    const mainChartCanvas = document.getElementById('stockPriceChart'); // The canvas itself

    mainChartCanvas.addEventListener('mousemove', function(e) {
        if (!stockChart || !stockChart.chartArea || ohlcData.length === 0) {
            // Hide all crosshair elements if chart is not ready or no data
            crosshairVertical.style.display = 'none';
            crosshairHorizontal.style.display = 'none';
            priceLabel.style.display = 'none';
            dateLabel.style.display = 'none';
            chartOverlayInfo.style.display = 'none';
            return;
        }

        const rect = mainChartCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        // Check if mouse is within the chart area
        if (y <= stockChart.chartArea.bottom && y >= stockChart.chartArea.top &&
            x >= stockChart.chartArea.left && x <= stockChart.chartArea.right) {

            crosshairVertical.style.display = 'block';
            crosshairHorizontal.style.display = 'block';
            crosshairVertical.style.left = x + 'px';
            crosshairHorizontal.style.top = y + 'px';

            // Get the value on the primary Y-axis (price)
            const yValue = stockChart.scales.y.getValueForPixel(y);
            priceLabel.style.display = 'block';
            priceLabel.style.top = y + 'px';
            priceLabel.style.right = (mainChartCanvas.width - stockChart.chartArea.right + 5) + 'px'; // +5 for padding
            priceLabel.textContent = '$' + yValue.toFixed(2);

            // For category scale, get data index using Chart.js helper
            const points = stockChart.getElementsAtEventForMode(e, 'index', { intersect: false }, true);
            if (points.length > 0) {
                const dataIndex = points[0].index;
                if (dataIndex >= 0 && dataIndex < ohlcData.length) {
                    const dataPoint = ohlcData[dataIndex]; // Use ohlcData for OHLCV
                    const pointDate = new Date(dataPoint.date);

                    dateLabel.style.display = 'block';
                    // Position date label relative to the chart area bottom
                    dateLabel.style.left = x + 'px';
                    dateLabel.style.bottom = (mainChartCanvas.height - stockChart.chartArea.bottom + 5) + 'px'; // Position below x-axis

                    dateLabel.textContent = pointDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });

                    chartOverlayInfo.style.display = 'block';
                    chartOverlayInfo.querySelector('.date span').textContent = pointDate.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric', year: 'numeric' });
                    chartOverlayInfo.querySelector('.open span').textContent = '$' + dataPoint.o.toFixed(2);
                    chartOverlayInfo.querySelector('.high span').textContent = '$' + dataPoint.h.toFixed(2);
                    chartOverlayInfo.querySelector('.low span').textContent = '$' + dataPoint.l.toFixed(2);
                    chartOverlayInfo.querySelector('.close span').textContent = '$' + dataPoint.c.toFixed(2);
                    chartOverlayInfo.querySelector('.volume span').textContent = dataPoint.v.toLocaleString();
                }
            } else {
                dateLabel.style.display = 'none';
                chartOverlayInfo.style.display = 'none';
            }
        } else {
            // Hide all crosshair elements if mouse leaves chart area
            crosshairVertical.style.display = 'none';
            crosshairHorizontal.style.display = 'none';
            priceLabel.style.display = 'none';
            dateLabel.style.display = 'none';
            chartOverlayInfo.style.display = 'none';
        }
    });

    mainChartCanvas.addEventListener('mouseleave', function() {
        crosshairVertical.style.display = 'none';
        crosshairHorizontal.style.display = 'none';
        priceLabel.style.display = 'none';
        dateLabel.style.display = 'none';
        chartOverlayInfo.style.display = 'none';
    });


    // Real-time updates for stock price
    if (enableRealTimeUpdates && ohlcData.length > 0) { // Only run if there's initial data
        const updateIntervalMs = 60000; // 60 seconds
        const currentPriceElement = document.querySelector('.current-price');
        const priceChangeElement = document.querySelector('.price-change');
        const lastUpdatedElement = document.querySelector('.last-updated');
        const loadingIndicator = document.querySelector('.chart-loading');

        function updateLatestPrice() {
            if (document.hidden) return; // Don't fetch if tab is not visible

            loadingIndicator.style.display = 'flex';
            fetch(`/company/api/company/${companyId}/latest-price`)
                .then(response => {
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    return response.json();
                })
                .then(data => {
                    if (data.success && data.price) {
                        const priceInfo = data.price;
                        currentPriceElement.textContent = '$' + parseFloat(priceInfo.price).toFixed(2);
                        const changeText = (priceInfo.change >= 0 ? '+' : '') +
                            `$${parseFloat(priceInfo.change).toFixed(2)} (${parseFloat(priceInfo.changePercent).toFixed(2)}%)`;
                        priceChangeElement.textContent = changeText;
                        priceChangeElement.className = 'price-change ' + (priceInfo.change >= 0 ? 'positive' : 'negative');
                        // Assuming timestamp is in seconds, convert to milliseconds for JS Date
                        lastUpdatedElement.textContent = 'Last updated: ' + new Date(priceInfo.timestamp * 1000).toLocaleString();

                        const latestDateObj = new Date(priceInfo.timestamp * 1000);
                        const latestDateStr = latestDateObj.toISOString().split('T')[0];
                        const lastChartDateStr = labels.length > 0 ? new Date(labels[labels.length - 1]).toISOString().split('T')[0] : null;

                        let dataUpdated = false;
                        // Make sure all necessary fields are present in priceInfo
                        const newOhlcv = {
                            date: latestDateStr,
                            o: parseFloat(priceInfo.open || priceInfo.price), // Fallback if open not present
                            h: parseFloat(priceInfo.high || priceInfo.price), // Fallback
                            l: parseFloat(priceInfo.low || priceInfo.price),   // Fallback
                            c: parseFloat(priceInfo.price),
                            v: parseInt(priceInfo.volume || 0)           // Fallback
                        };


                        if (labels.length === 0 || latestDateStr !== lastChartDateStr || currentInterval === 'intraday') { // Add new point
                            ohlcData.push(newOhlcv); // Update the source of truth
                            // Re-prepare data arrays for Chart.js datasets
                            const prepared = prepareChartData(ohlcData);
                            labels = prepared.labels;
                            prices = prepared.prices;
                            volumes = prepared.volumes;
                            dataUpdated = true;
                        } else { // Update last point for the current day
                            const lastIdx = ohlcData.length - 1;
                            ohlcData[lastIdx].h = Math.max(ohlcData[lastIdx].h, newOhlcv.h);
                            ohlcData[lastIdx].l = Math.min(ohlcData[lastIdx].l, newOhlcv.l);
                            ohlcData[lastIdx].c = newOhlcv.c;
                            ohlcData[lastIdx].v = newOhlcv.v; // Or += if volume is incremental

                            // Update the corresponding data arrays used by Chart.js datasets
                            prices[lastIdx] = newOhlcv.c;
                            volumes[lastIdx] = newOhlcv.v;
                            dataUpdated = true;
                        }

                        if (dataUpdated && stockChart) {
                            updateChartColorsAndData(); // Recalculate trend colors
                            stockChart.data.labels = labels; // Update labels for category scale

                            // Update datasets
                            stockChart.data.datasets[0].data = (stockChart.config.type === 'line') ? prices : ohlcData.map(d=>d.c);
                            stockChart.data.datasets[1].data = volumes;

                            stockChart.update('none'); // 'none' for no animation
                        }
                    } else {
                        console.warn("Latest price update failed or no price data:", data.message);
                    }
                })
                .catch(error => console.error('Error fetching latest price:', error))
                .finally(() => loadingIndicator.style.display = 'none');
        }
        // Initial update after a short delay, then interval
        // setTimeout(updateLatestPrice, 5000); // This might be too soon if page is still loading fully
        const realTimeUpdateIntervalId = setInterval(updateLatestPrice, updateIntervalMs);
        // Optional: clear interval when page is hidden and restart when visible
        document.addEventListener("visibilitychange", () => {
            if (document.hidden) {
                // clearInterval(realTimeUpdateIntervalId); // Or just skip fetch in updateLatestPrice
            } else {
                updateLatestPrice(); // Fetch immediately when tab becomes visible
                // realTimeUpdateIntervalId = setInterval(updateLatestPrice, updateIntervalMs);
            }
        });

    }


    function loadHistoricalData(interval, range, forceRefresh = false) {
        currentInterval = interval;
        currentTimeRange = range;

        const loadingIndicator = document.querySelector('.chart-loading');
        loadingIndicator.style.display = 'flex';
        // Hide chart canvas while loading new data to prevent visual glitches
        document.getElementById('stockPriceChart').style.visibility = 'hidden';

        console.log(`Loading historical data: interval=${interval}, range=${range}, refresh=${forceRefresh}`);

        const url = forceRefresh ?
            `/company/api/company/${companyId}/historical-prices?interval=${encodeURIComponent(interval)}&range=${encodeURIComponent(range)}&refresh=true` :
            `/company/api/company/${companyId}/historical-prices?interval=${encodeURIComponent(interval)}&range=${encodeURIComponent(range)}`;

        fetch(url)
            .then(response => {
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    // First, ensure we show the canvas and hide the no-data message
                    document.getElementById('stockPriceChart').style.display = 'block';
                    const noDataMsg = document.querySelector('.no-data-message');
                    if (noDataMsg) {
                        noDataMsg.style.display = 'none';
                    }

                    if (data.prices && data.prices.length > 0) {
                        priceData = data.prices; // Update the source of truth
                        console.log(`Received ${data.prices.length} data points for ${companySymbol}`);
                        console.log('First data point:', data.prices[0]);
                        const prepared = prepareChartData(priceData);
                        labels = prepared.labels;
                        prices = prepared.prices;
                        volumes = prepared.volumes;
                        ohlcData = prepared.ohlcData; // Ensure ohlcData is also updated
                    } else { // API returned success but no data points for the range
                        priceData = []; labels = []; prices = []; volumes = []; ohlcData = [];
                        console.warn("No historical data points returned for range:", range, "interval:", interval);

                        // Show no-data message and hide chart
                        document.getElementById('stockPriceChart').style.display = 'none';
                        if (noDataMsg) {
                            // Update message with API-provided message if available
                            if (data.message) {
                                const errorDetails = noDataMsg.querySelector('.mb-0.text-muted');
                                if (errorDetails) {
                                    errorDetails.textContent = 'Reason: ' + data.message;
                                }
                            }
                            noDataMsg.style.display = 'block';
                        }
                    }

                    if (stockChart) {
                        updateChartColorsAndData(); // Recalculate trend colors

                        stockChart.data.labels = labels; // Update labels for category scale

                        // Update datasets
                        // Determine the right data based on chart type
                        if (stockChart.config.type === 'line') {
                            stockChart.data.datasets[0].data = prices;
                        } else {
                            // For custom chart types, we update the base data that the plugin will use
                            stockChart.data.datasets[0].data = ohlcData.map(d => d.c);
                        }
                        stockChart.data.datasets[1].data = volumes;

                        stockChart.update();
                    } else {
                         // If chart wasn't created initially (e.g., no data), create it now if data is available
                         if (priceData.length > 0) {
                              createOrUpdateChart();
                         }
                    }

                    // Update last updated time (assuming API response includes it or use current time)
                    document.querySelector('.last-updated').textContent = 'Last updated: ' + new Date().toLocaleString(); // Using current time as fallback


                } else {
                    console.error('Failed to load historical data or invalid format:', data.message || 'Unknown error');
                     // Optionally, clear the chart or show an error message on the chart
                    priceData = []; labels = []; prices = []; volumes = []; ohlcData = [];
                    if (stockChart) {
                        updateChartColorsAndData();
                        stockChart.data.labels = []; stockChart.data.datasets[0].data = []; stockChart.data.datasets[1].data = [];
                        stockChart.update();
                    }
                    document.querySelector('.last-updated').textContent = 'Last updated: Error loading data.';
                }
            })
            .catch(error => {
                console.error('Error fetching historical data:', error);
                priceData = []; labels = []; prices = []; volumes = []; ohlcData = []; // Clear data on error

                // Show error message
                const noDataMsg = document.querySelector('.no-data-message');
                if (noDataMsg) {
                    // Update error message with actual error if available
                    const errorDetails = noDataMsg.querySelector('.mb-0.text-muted');
                    if (errorDetails) {
                        errorDetails.textContent = 'Error details: ' +
                            (error.message || 'Unable to fetch historical price data for ' + companySymbol);
                    }
                    noDataMsg.style.display = 'block';
                }

                // Hide the chart canvas
                const chartCanvas = document.getElementById('stockPriceChart');
                if (chartCanvas) {
                    chartCanvas.style.display = 'none';
                }

                // Clear chart data if it exists
                if (stockChart) {
                    stockChart.data.labels = [];
                    stockChart.data.datasets[0].data = [];
                    stockChart.data.datasets[1].data = [];
                    stockChart.update('none'); // 'none' for no animation
                }

                document.querySelector('.last-updated').textContent = 'Last updated: Error loading data';
            })
            .finally(() => {
                loadingIndicator.style.display = 'none';
                document.getElementById('stockPriceChart').style.visibility = 'visible';
            });
    }

    document.querySelectorAll('.time-range-selector .btn').forEach(button => {
        button.addEventListener('click', function(e) {
            e.preventDefault();
            const newRange = this.getAttribute('href').match(/range=([^&]+)/)[1];
            if (newRange === currentTimeRange && this.classList.contains('active')) return;

            document.querySelectorAll('.time-range-selector .btn').forEach(btn => {
                btn.classList.remove('active', 'btn-primary');
                btn.classList.add('btn-outline-secondary');
            });
            this.classList.add('active', 'btn-primary');
            this.classList.remove('btn-outline-secondary');

            loadHistoricalData(currentInterval, newRange);
            window.history.pushState({interval: currentInterval, range: newRange}, '', this.href);
        });
    });

    document.querySelectorAll('.interval-selector .btn').forEach(button => {
        button.addEventListener('click', function(e) {
            e.preventDefault();
            const newInterval = this.getAttribute('href').match(/interval=([^&]+)/)[1];
             if (newInterval === currentInterval && this.classList.contains('btn-primary')) return;


            document.querySelectorAll('.interval-selector .btn').forEach(btn => {
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-outline-primary');
            });
            this.classList.add('btn-primary');
            this.classList.remove('btn-outline-primary');

            loadHistoricalData(newInterval, currentTimeRange);
            window.history.pushState({interval: newInterval, range: currentTimeRange}, '', this.href);
        });
    });

    // Handle back/forward browser navigation for chart state
    window.addEventListener('popstate', (event) => {
        if (event.state && event.state.interval && event.state.range) {
            // Update UI for interval buttons
            document.querySelectorAll('.interval-selector .btn').forEach(btn => {
                const btnInterval = btn.getAttribute('href').match(/interval=([^&]+)/)[1];
                if (btnInterval === event.state.interval) {
                    btn.classList.add('btn-primary');
                    btn.classList.remove('btn-outline-primary');
                } else {
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-outline-primary');
                }
            });
            // Update UI for time range buttons
            document.querySelectorAll('.time-range-selector .btn').forEach(btn => {
                const btnRange = btn.getAttribute('href').match(/range=([^&]+)/)[1];
                 if (btnRange === event.state.range) {
                    btn.classList.add('active', 'btn-primary');
                    btn.classList.remove('btn-outline-secondary');
                } else {
                    btn.classList.remove('active', 'btn-primary');
                    btn.classList.add('btn-outline-secondary');
                }
            });
            loadHistoricalData(event.state.interval, event.state.range);
        } else {
            // Fallback if state is not set, maybe reload from initial params
            // Or parse URL:
            const params = new URLSearchParams(window.location.search);
            const urlInterval = params.get('interval') || '{{ interval|e('js') }}';
            const urlRange = params.get('range') || '{{ timeRange|e('js') }}';
            loadHistoricalData(urlInterval, urlRange);
        }
    });

});
</script>
